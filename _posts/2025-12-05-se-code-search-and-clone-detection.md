---
title: Software Engineering Code Search
date: 2025-12-05 18:22:12 +09:00
categories: ['se']
tags: ['se', 'code search', 'clone detection']
mermaid: true
math: true
---

대규모 소프트웨어 시스템에서 개발자는 이미 존재하는 코드를 반복해서 작성하는 경우가 많습니다. 이는 필요한 코드를 찾기 어렵거나, 기존 코드의 존재를 인지하지 못하기 때문입니다. Code Search와 Clone Detection은 이러한 문제를 해결하기 위한 대표적인 소프트웨어 공학 과제입니다. 두 작업 모두 “유사한 코드를 찾는다”는 공통점을 가지지만, 목적과 활용 방식은 다릅니다.

## Code Search 개념

Code Search는 주어진 질의에 대해 적절한 코드 조각을 찾는 작업입니다. 질의는 자연어일 수도 있고, 코드일 수도 있습니다.

- 자연어 질의는 요구사항을 설명합니다.
- 코드 질의는 유사한 구현을 찾는 데 사용됩니다.
- 목적은 개발자의 코드 탐색 비용을 줄이는 것입니다.
- 재사용 가능한 코드 조각을 찾는 데 활용됩니다.

Code Search는 단순한 문자열 검색이 아니라, 의미적으로 관련된 코드를 찾는 작업입니다.

## 전통적인 Code Search 접근

기존의 Code Search 기법은 코드를 특정 표현으로 변환한 뒤, 그 표현을 기반으로 검색을 수행합니다.

- 코드를 토큰, AST, 그래프 등으로 변환합니다.
- 코드 주석, 문서, 실행 결과 같은 보조 정보를 활용합니다.
- 질의와 코드 표현 간의 유사도를 계산합니다.

이 방식은 특정 언어와 규칙에 강하게 의존하며, 의미 수준의 유사성을 포착하는 데 한계가 있습니다.

## LLM 기반 Code Search

대규모 언어 모델은 방대한 코드 데이터를 학습하면서 코드의 문법과 의미를 함께 학습합니다. 이로 인해 Code Search의 패러다임이 변화하고 있습니다.

- 자연어 질의에 대해 코드를 직접 생성할 수 있습니다.
- 생성된 코드는 “검색 결과”로 해석될 수 있습니다.
- 벡터 데이터베이스를 이용한 코드 임베딩 검색이 활용됩니다.
- Retrieval-Augmented Generation에서 핵심 구성 요소로 사용됩니다.

LLM 환경에서 Code Search는 “찾기”보다는 “적절한 코드를 불러오는 검색”에 더 가깝습니다.

## Code Search 흐름

```mermaid
flowchart LR
  Q["Query<br>(NL or Code)"] --> E[Embedding]
  E --> V[Vector Database]
  V --> R[Retrieved Code]
  R --> G["Generation or Suggestion"]
````

이 흐름은 코드 검색이 단독 작업이 아니라, 코드 생성 및 보완과 결합되는 구조임을 보여줍니다.

## Code Clones 개념

Code Clone은 동일하거나 충분히 유사한 코드 조각을 의미합니다.

* 동일한 코드를 복사해 사용한 경우
* 구조는 같고 이름만 다른 경우
* 일부 수정된 코드
* 구현은 다르지만 동일한 기능을 수행하는 경우

코드 클론은 전통적으로 “나쁜 냄새”로 간주되었으나, 항상 제거 대상은 아닙니다. 일부 연구에서는 코드 클론이 오히려 안정적이라는 결과도 보고되었습니다.

## Code Clone의 유형

코드 클론은 일반적으로 네 가지 유형으로 분류됩니다.

* Type-1

  * 공백이나 주석을 제외하면 동일한 코드입니다.
* Type-2

  * 변수명이나 타입만 다르고 구조는 동일합니다.
* Type-3

  * 일부 문장이 추가·삭제·수정된 경우입니다.
* Type-4

  * 문법은 다르지만 의미적으로 동일한 기능을 수행합니다.

Type-4 클론은 의미 수준 비교가 필요하므로 탐지가 가장 어렵습니다.

## 전통적인 Clone Detection 기법

Clone Detection은 주로 두 가지 접근으로 나뉩니다.

* 토큰 기반 기법

  * 코드를 토큰 시퀀스로 변환합니다.
  * 유사한 토큰 패턴을 탐지합니다.
* 트리 기반 기법

  * 코드를 AST로 변환합니다.
  * 유사한 서브트리를 비교합니다.

이들 기법은 주로 Type-2, 일부 Type-3 클론 탐지에 강점을 가집니다. Type-4 클론 탐지는 제한적으로만 가능했습니다.

## LLM 기반 Clone Detection

LLM은 코드의 의미를 자연어 수준으로 표현할 수 있기 때문에, 의미적 유사성을 포착하는 데 유리합니다.

* 코드에서 핵심 의미 단어를 추출합니다.
* 코드 설명 간의 의미 유사도를 비교합니다.
* Type-3, Type-4 클론 탐지에서 강점을 보입니다.

다만 기존 기법에 비해 정확도가 항상 우수한 것은 아니며, 두 접근은 상호 보완적인 관계에 있습니다.

## Clone Detection 흐름

```mermaid
flowchart LR
  C1[Code Fragment A] --> E1[Semantic Representation]
  C2[Code Fragment B] --> E2[Semantic Representation]
  E1 --> S[Similarity Check]
  E2 --> S
  S --> D[Clone Decision]
```

이 구조는 문법 중심 비교에서 의미 중심 비교로의 전환을 보여줍니다.

## Code Search와 Clone Detection의 관계

두 작업은 모두 유사한 코드를 찾는다는 공통점을 가집니다.

* Code Search는 “찾고 싶은 코드”가 기준입니다.
* Clone Detection은 “중복되거나 유사한 코드”가 기준입니다.
* 목적과 적용 맥락이 다를 뿐, 핵심 기술은 공유됩니다.

LLM의 도입으로 두 작업의 경계는 점점 흐려지고 있습니다.


## 맺음말

> Code Search와 Clone Detection은 대규모 코드베이스에서 생산성과 품질을 동시에 높이기 위한 핵심 기술입니다. 
> 전통적인 기법은 구조적 유사성 탐지에 강점을 가지며, LLM은 의미적 유사성 포착에 강점을 가집니다. 
> 실제 시스템에서는 단일 접근보다 여러 기법을 결합하는 것이 합리적입니다. 
> LLM은 이 영역의 가능성을 크게 확장했지만, 정확성·비용·평가 방식 측면에서 여전히 연구와 개선의 여지가 남아 있습니다.

